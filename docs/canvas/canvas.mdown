Canvas全记录
================



[TOC]
#`游戏的基本内容`

###1.1什么是动画

      动画是通过连续播放一系列画面，给视觉造成连续变化的图画。它的基本原理与电影、电视一样，都是视觉原理。医学已证明，人类具有视觉暂留的特性，就是说人的眼睛看到一幅画或一个物体后，在1/24秒内不会消失。利用这一原理，在一幅画还没有消失前播放出下一幅画，就会给人造成一种流畅的视觉变化效果。因此，电影采用了每秒24幅画面的速度拍摄播放，电视采用了每秒25幅（PAL制，中央电视台的动画就是PAL制）或30幅（NSTC制）画面的速度拍摄播放。如果以每秒低于24幅画面的速度拍摄播放，就会出现停顿现象。

        从播放效果上看，分为顺序动画（连续动作）和交互式动画（反复动作）。逐帧动画是一种常见的动画形式（Frame By Frame），其原理是在“连续的关键帧”中分解动画动作，也就是在时间轴的每帧上逐帧绘制不同的内容，使其连续播放而成动画。
###1.2使用HTML5来做动画

        HTML5制作的动画主要是逐帧动画。目前主要有DOM, SVG与Canvas三种方式来实现。在此我们主要讨论Canvas方式来制作动画。

Canvas的支持

       到目前为止，基本所有浏览器 的最新版本均提供了对canvas的全面支持。基于“渐近增强，优雅降级”的移动互联网应用体验，如果用户使用的浏览器版本较低，可以在canvas标签中写入信息来提示用户升级浏览器。如：


    <canvas>您的浏览器不支持此动画，请升级您的浏览器</canvas>  

 如果要使用编程的方式来检测对于canvas的支持程度，可以使用如下代码：


    if(document.createElement(“canvas”).getContext(“2d”)){  
             console.log(“当前浏览器支持canvas”);  
    }  

当然，也可以引入第三方的开源JavaScript库(http://code.google.com/p/explorercanvas/),在不支持canvas的浏览器中来模拟canvas的各种API。由于各个设备及浏览器版本的实现方式不同，为了保证用户得到一致的体验，我们需要在尽可能多的设备及浏览器上对我们的游戏进行测试及调优。

###HTML5基本文档模板

         我们的游戏需要在一个HTML文档中的canvas标签中渲染，在此我们创建一个最基本的HTML文档模板。如下
```html

    <!doctype html>  
    <html>  
    <head>  
    <meta charset="utf-8">  
    <title>base canvas</title>  
    <link rel="stylesheet"  type=”text/css”   href="style.css">  
    </head>  
    <body>  
    <canvas id="canvas" width="400" height="400"></canvas>  
    <script type=”text/javascript”>  
    window.onload = function () {  
      
    };  
    </script>  
    </body>  
    </html>  
```

简单浏览一下，刚开始我们定义了HTML5文档类型，之后定义了header标签，引用了外部的CSS文件。然后在body中定义了一个canvas标签来做为我们的游戏渲染容器。在body标签结束前，我们创建了一个script标签，在其中来使用JavaScript来实现我们的游戏(之所以在header中使用link标签来加载外部css文件，或在body结束标签前再定义script标签、引入外部JavaScript文件，是为了保证页面的逐步呈现速度，保证浏览器更高效地渲染HTML页面，提高脚本下载的并行度，参见Steve Souders大神的《高性能网站建设指南》).
      可以看到，在脚本中我们为window对象的onload事件指定了回调函数，即在所有的文档元素加载完成后，再执行回调函数中的程序。这可以保证canvas标签在我们使用之前已经创建成功。当然，如果当前的HTML文档中有大量的资源（如图片，音乐等）需要加载，那我们的window.onload事件会需要等待很长的时间才能执行，在这种情况下最好是使用脚本来动态加载相应的资源，之后会介绍到相关的知识。

其它

 

随着开发游戏的复杂度增加，我们的代码量及程序复杂度会随之增长，这就需要我们对游戏进行建模，将代码按一定的规则放置在外部脚本文件中引入。

同时，游戏开发中一个好的编辑器与调试工具也会得到事半功倍的效果。在此我们使用 sublime text2 来做为编辑器，使用 chrome 中的开发人员工具来做为调试工具。

 
###1.3 逐帧动画

 

因为 canvas 动画是逐帧动画，所以我们需要有一个循环来控制动画中的每一帧的渲染。而对于每一帧动画的渲染，会按如下序列进行：

a. 执行计算当前帧动作的所有代码，将其结果调用 canvas API 放入内存

b. 将内存中当前帧渲染到 canvas 容器中

c. 进入下一帧的处理流程（通常会在此时擦除画布）

在 JavaScript 中，有两个函数 setTimeout 与 setInterval 通常用来进行相关的计时调用。 setTimeout 只会执行回调函数一次， setInterval 会每隔 X 毫秒执行函数一次。但这两个函数均不是为开发游戏而生，都存在着一些问题。

基于 JavaScript 引擎的计时策略，以及本质上的单线程运行方式，所以其它代码的运行可能会阻塞此线程。因此没法确保 函数会在 setTimeout 指定的时刻被调用。而当回调函数的执行被阻塞时， setInterval 仍然会发布更多的毁掉指令。在很小的定时间隔情况下，这会导致回调函数被堆积起来。所以通常我们不建议使用 setInterval, 而是采用 setTimeout 来替代，最简单的处理回调函数被阻塞的情况就是在回调函数中再调用 setTimeout.( 具体参见 JavaScript Garden http://bonsaiden.github.com/JavaScript-Garden/zh/ ) .

但是，随着对动画的流畅度要求提高，如果有大量定时器在同时运行，这些定时器之间的调度会对性能有轻微的影响。一种解决方案就是实现一个采用帧管理的动画框架，通过一个定时器触发动画帧，不同的动画来注册这些帧，在每一帧上处理多个动画的属性变化。这样的好处是减少了定时器调度的开销，但是对于动画框架的开发者来说，统一帧管理、提供监听帧的API等，都是需要开发和维护的。浏览器厂商目前提供一个专门做动画的方法，即requestAnimationFrame()，从浏览器的层面对帧动画进行了优化，如下代码示例（参见http://paulirish.com/2011/requestanimationframe-for-smart-animating/）。
```js

    window.requestAnimFrame = (function(){  
          return  window.requestAnimationFrame       ||   
                  window.webkitRequestAnimationFrame ||   
                  window.mozRequestAnimationFrame    ||   
                  window.oRequestAnimationFrame      ||   
                  window.msRequestAnimationFrame     ||   
                  function( callback ){  
                    window.setTimeout(callback, 1000 / 60);  
                  };  
        })();  
    (function animloop(){  
          requestAnimFrame(animloop);  
          render();  
    })();  

 
```
 

 
###1.4 JavaScript对象知识

        JavaScript是一个基于对象的语言，它的对象就是一种包含属性的特殊的数据结构，这此属性可以是变量，函数或其它对象。同时JavaScript对象可以随时被动态改变。如：

 


    var  objectA={};  
    objectA.name=”objectA”;  

 如果我们需要同时创建同一类型的对象，可以使用构造函数的形式。JavaScript的构造函数是一种特殊的函数，它可以基于设置给自身的属性来生成对象。在创建了构造函数后，我们就可以使用new关键字来生成对象了。如：
```js

    function Animal(name){  
           this.name=name || “animal”;  
           this.say=function(){   console.log(this.name);  
    }  
      
    var dog=new Animal(“dog”);   dog.say();  
    var cat=new Animal(“cat”);    cat.say();  
```    

JavaScript是基于原型的一种语言。在我们创建了一个新的对象实例时，实际是我们是创建了一个对象，这个对象继承了构造函数的原型链（具体参见《JavaScript面向对象编程》及http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance.html 或http://7685941014.blog.163.com/blog/static/124615480201061782347164/ ）

```js
    function Person(name){    
           this.name=name;    
           console.log(this.name);   
    }  
      
     function Student(name,school){    
           Person.call(this,name);   
           this.school=school;   
    }  
      
    Student.prototype=new Person();  
    Student.prototype.constructer=Student;  
```    

由于JavaScript的函数也是一种对象，所以，可以给函数设置属性及方法。比如很多时候我们使用的回调方法等。如：


    var person=[“Jim”,”James”,”Kimmy”];   
      
    person.forEach(function(o,i){   console.log(i+”,”+o);  }  

直接构造for循环或者使用forEach方法来遍历Array的所有元素，在Array对象的元素数目很大的情况下，使用forEach方法会有效率上的问题。与此类似，在使用for…in 循环来遍历对象的所有属性时，如果对象的原型链嵌套层次比较深，也会导致效率上有问题。(for … in不能遍历出enumerable为false的属性，如Array的length属性)。

 
###1.5用户交互

     游戏的核心在于用户交互性，用户交互是基于事件的。事件包括监听器及事件处理。在canvas上绘制的图形自身不支持DOM事件检测，只有canvas标签自身支持DOM整件监听。因此需要对canvas容器的事件进行处理，实现相对事件监听及处理。

      按W3C的规范http://www.w3.org/TR/DOM-Level-3-Events ，我们可以为对象注册事件，如下：


    element.addEventListener(type, handler [, useCapture]);  

 一个典型监听鼠标点击的事件如下：

```js
    canvas.addEventListener('mousedown', function (event) {  
          console.log("Mouse pressed on element!");  
    }, false);  

```    

换句话说，每一个对象都订阅了指定的事件触发事件，在该事件触发时，会将此信息广播给所有订阅其信息的对象，此对象再调用对应的事件触发回调函数来进行处理。如果我们想注销某一个事件，则使用


    element.removeEventListener(type, handler [, useCapture]);  

 

#鼠标事件

 

      鼠标事件包括mousedown,mouseup,mouseover等。如果需要获取鼠标位置时，在监听到mousemove事件响应后，可做如下处理：
```js

    var utils={};  
    utils.cpatureMousePosition=function(element){  
         var mouse={x:0,y:0};  
         element.addEventListener("mousemove",function(event){  
               var x,y;  
               if(event.pageX||event.pageY){  
                      x=event.pageX;  
                      y=event.pageY;  
               }else{  
                      x=event.clientX+document.body.scrollLeft+document.documentElement.scrollLeft;  
                      y=event.clientY+document.body.scrollTop+document.documentElement.scrollTop;  
               }  
               x-=element.offsetLeft;  
               y-=element.offsetTop;  
               mouse.x=x;  
               mouse.y=y;  
           },false);  
           return mouse;  
    };  
```

具体的原因在于各个浏览器对于鼠标位置的处理实现方式与提供的接口不同：参见http://www.seobye.com/div-css/87/及http://javascript.about.com/library/blmousepos.htm，可以在页面中使用上面定义的方法：

```html

    <!doctype html>  
    <html>  
    <head>  
    <meta charset="utf-8">  
    <title>Get Mouse Position</title>  
    <link rel="stylesheet"  type=”text/css”   href="style.css">  
    </head>  
    <body>  
    <canvas id="canvas" width="400" height="400"></canvas>  
    <script type=”text/javascript”>  
    window.onload = function () {  
                  var canvas=document.getElementById(“canvas”);  
                  var mouse=utils.captureMousePosition(canvas);  
                  (function drawFrame(){  
                                window.requestAnimFrame(drawFrame,canvas);  
                                console.log(mouse.x+”,”+mouse.y);  
                  })();  
    };  
    </script>  
    </body>  
    </html>  

```

#键盘事件
       有两个键盘事件——keydown与keyup。可以通过event.keyCode (https://github.com/lamberta/html5-animation/blob/master/xtras/keycode.js )来获取当前键盘值的ASCII值。然后使用switch来区分处理具体的按键并加以处理。如下：
```js

    element.addEventListener(“keyup”,function(event){  
                  switch(event.keyCode){  
                       case:   break;  
                 }  
    },false);  
```

[TOC]
#`数学知识`

#角度

以弧度为单位的,角度与弧度之间的换算单位
>radians=degrees*Math.PI/180

同时，在canvas中的坐标系是以右上角为原点(0,0),向左为x轴增加方向，向下为y轴增加方向。因此，需要特别注意canvas中角度是以顺时针为方向的，这与我们在生活中角度为逆时针相反。如下图：


在三角函数中，最常用的有三个，Math.cos,Math.sin与Math.atan2,注意计算反正切的有两个函数Math.atan与Math.atan2，后者需要传入对边dy与邻边dx来求得精确的角度（在[-180，180]中正切值相同的角度会有两个）。如下:



 可以看出，对D角使用Math.atan2来得到的值将为-153.43。因此，如果我们需要求得任意一点P(x,y)与原点连线的角度，使用Math.atan2(y,x)即可。

#旋转

 在游戏开发中，我们经常会碰到对于画布中对象的旋转，即使用到context.rotate方法，而其角度大多数情况下通过上述的Math.atan2(dy,dx)获得。计算一个动点与一个静点之间的实时角度，假设静点为originX,originY，动点为x,y.  则

 >α=Math.atan2(y-originY,x-originX)  

 如果给静点的rotation方法传入α后重绘，就会出现实时地让静点指向动点。如下即为一个随着鼠标移动而随时指向鼠标的箭头实现。

 ```js

    //箭头类  
    function Arrow(){  
            //定义位置属性  
        this.x=0;  
        this.y=0;  
            //定义旋转角度及缩放  
        this.rotation=0;  
        this.scaleX=1;  
        this.scaleY=1;  
            //定义填充色及画笔宽度  
        this.color='#00ff00';  
        this.lineWidth=1;  
    }  
    //绘制方法  
    Arrow.prototype.paint=function(context){  
            //保存场景  
        context.save();  
            //坐标系转换，缩放及旋转  
        context.translate(this.x,this.y);  
        context.scale(this.scaleX,this.scaleY);  
        context.rotate(this.rotation);  
            //定义填充色及画笔  
        context.fillStyle=this.color;  
        context.lineWidth=1;  
            //绘制箭头  
        context.beginPath();  
        context.moveTo(-50,-25);  
        context.lineTo(0,-25);  
        context.lineTo(0,-50);  
        context.lineTo(50,0);  
        context.lineTo(0,50);  
        context.lineTo(0,25);  
        context.lineTo(-50,25);  
        context.closePath();  
            //填充  
        context.fill();  
        if(context.lineWidth>0){  
            context.stroke();  
        }  
        context.restore();  
    }  

 ```

#波动

 正弦与余弦的曲线都是一条规律性的波动曲线，游戏中很多对象的往复运动就是按正余弦规律来进行的。使用canvas我们很容易就能绘制出一条正弦曲线。如下：

 ```js

 //绘制Sin曲线，给定起始点坐标及波动高与宽  
function getSinWave(context,x,y,width,height){  
    context.save();  
    context.translate(x,y);  
    context.beginPath();  
    for(var i=0;i<360;i+=0.1){   context.lineTo(i*width,Math.sin(i*width*Math.PI/180)*height);  
    context.stroke();  
    context.restore();  
}  
```

###弹簧振子往复运动

对于物理学中的弹簧振子来说，其在一个坐标轴中的运动就是正余弦曲线在Y轴上的投影。如下为一个小球的运动。

```js

    //小球类，给定半径及填充色  
    function Ball(radius,color){  
            //设置球心及缩放，边缘线宽  
        this.x=0;  
        this.y=0;  
        this.radius=radius||20;  
        this.color=color||'#ffff00';  
        this.scaleX=1;  
        this.scaleY=1;  
        this.lineWidth=1;  
    }  
    //定义绘制方法  
    Ball.prototype.paint=function(context){  
        context.save();  
            //坐标转换  
        context.translate(this.x,this.y);  
        context.scale(this.scaleX,this.scaleY);  
        context.fillStyle=this.color;  
        context.lineWidth=this.lineWidth;  
        context.beginPath();  
            //绘制球  
        context.arc(0,0,this.radius,0,Math.PI*2,true);  
        context.closePath();  
        context.fill();  
        if(context.lineWidth>0){  
            context.stroke();  
        }  
        context.restore();  
    };  
```

如下为具体的呈现HTML文档，在utils.js中定义了window.requestAnimFrame的实现类（详见分享一).

```html
    <!DOCTYPE html>  
    <html>  
        <head>  
            <meta charset="utf-8" />  
            <title>Ball</title>  
        </head>  
        <body>  
            <canvas id="canvas" width="400" height="400"></canvas>  
            <script type="text/javascript" src="utils.js"></script>  
            <script type="text/javascript" src="ball.js"></script>  
            <script type="text/javascript">  
                window.onload=function(){  
                                   //获取canvas标签引用及canvas绘图上下文context  
                                    var canvas=document.getElementById("canvas");  
                    var context=canvas.getContext("2d");  
                                   //实例化小球  
                    var ball=new Ball();  
                    ball.x=canvas.width/2;  
                    ball.y=canvas.height/2;  
                                    //初始化角度及角度增加系数  
                    var angle=0;  
                    var vr=1*Math.PI/180;  
                    (function animationLoop(){  
                        window.requestAnimFrame(animationLoop,canvas);  
                        context.clearRect(0,0,canvas.width,canvas.height);  
                                            //以60帧的速度来绘制弹簧振子小球的运动  
                        ball.x=canvas.width/2*(1-Math.cos(angle));  
                        angle+=vr;  
                        ball.paint(context);  
                    })();  
                };  
            </script>  
        </body>  
    </html>  
```   

###线性垂直波动

如果给以正余弦方式垂直运动的对象加上一个横向的线速度，那就会动态地绘制出一个正余弦曲线。我们为ball添加vx,vy属性。

```js

    (function aniamtionLoop(){  
        window.requestAnimation(animationLoop,canvas);  
        context.clearRect(0,0,canvas.width,canvas.height);  
        ball.x+=ball.vx;  
        angle+=ball.vy*Math.PI/180;  
        ball.y=Math.cos(angle)*canvas.height/2;  
        ball.paint(context);  
    })();  

```

###脉冲效果

除了为对象在X与Y轴方向上添加正余弦变化的速度外，也可以为对象的其它属性，    如尺寸添加一个按正弦变化的值，这将会产生一种脉冲效果。

>ball.scaleX=ball.scaleY=Math.PI*angle/180;

此处使用的是同一个变化量，其实也可以为不同的属性指定不同的角度。

###圆周运动 

对一个圆周上运动的对象来说，其任意时刻在圆周上的位置可以使用半径与三角函数来表示。即P(x,y)=P(r1*cosα,r2*sinα)。如果r1=r2，则运动对象的轨迹为一个正圆，否则其轨迹为一个椭圆。

>ball.x=canvas.width/2+Math.cos(angle)*radiusX;
ball.y=canvas.height/2+Math.sin(angle)*radiusY; 

三角函数在动画中计算坐标，最常见的一定是使用余弦Math.cos来计算横坐标x,使用正弦Math.sin来计算纵坐标y。

###勾股定理及距离计算

距离的计算相当常见，我们只需要在坐标系中使用勾股定理，即A(x0,y0)到B(x1,y1)之间的距离为

```js

var dx=B.x-A.x;  
var dy=B.y-A.y;  
var distance=Math.sqrt(dx*dx+dy*dy);

```


[TOC]
#`Canvas 常见用法`

#canvas中的色彩

 对于canvas中色彩的表示，主要沿用CSS的四种方式：


    #RRGGBB   十六进制表示法
    #RGB   上述十六进制中特殊色彩的简写表达，两种表示法的对应关系为复制R，G，B位上的数值，如#0bf是#00bbff的简写表达方式
    rgb(R,G,B)   函数式的表达方式，各色彩取值为0~255
    rgba(R,G,B,A)   在上述基础上添加了对透明度的支持

虽然最终色彩是以字符串的方式表示，但实际操作时还是会用数字来描述色彩。由于每一种色彩均使用8个bit来表示，所以以上色彩表示方式称为24 bit表示法。

###16进制色彩的生成

在JavaScript中，16进制表法为0x与对应的16进制数值。如0xf为十进制中的15。如果我们使用控制台来打印一个16进制的数，将会默认得到其十进制表示。如

>console.log(0xFF55F3);

将会输出16733683。同时JavaScript的Number对象提供的toString方法，在指定参数（进制数）后，可以实现进制的转换。

>var color=(16733683).toString(16);

将会得到color的值为ff55f3。于是，我们得到了色彩字符串与对应十进制数字的相互转换方式：

-色彩字符串转数字 

>var color=’#ff00ff’;
var colorNumber=window.parseInt(color.slice(1),16);

-任意数字转色彩字符

>var colorNumber=16711935;  
var color=’#’+colorNumber.toString(16);

很多时候，我们需要独立操作24bit色彩中的R,G,B三色值，此时就需要将色彩进行处理。可以使用“移位”符号和按位“与”符号，有如下的变换公式：
>var red=color >> 16 && 0xff;  
var green=color >> 8 && 0xff;  
var blue=color && 0xff;

对应地，如果我们已知R,G,B三色值，可以使用如下变换公式来组合为24bit色彩值

>var color=red<<16 | green <<8 | blue;

通过上面的知识，我们很容易就得到几个对色彩进行处理的工具函数：

```js

    utils.getRandomColor=function(){  
        var colorNumber=Math.random()*0xffffff|0;  
        var color='#'+('00000'+colorNumber.toString(16)).substr(-6);  
        return color;  
    }  

```
`【注】使用位运算符|可以实现去除数字小数部分的功能：1.1|0=1    11.1|0=11   -12.6|0=-12`

#canvas上下文及clearRect

Canvas标签的大多数API的调用，都依赖于其上下文对象。很容易就能获取上下文对象，如：

```js

    var canvas=document.getElementById(“canvas”);  
    var context=canvas.getContext(canvas);  

```

前面介绍到，canvas 实现的游戏主要是逐帧动画。大多数游戏场景中，在每一帧开始前，都需要清除之前帧的所有信息，此时就会用到clearRect方法。如：

>context.clearRect(0,0,canvas.width,canvas.height);  

此时，我们是将整个画布给清空。当然，效率更高的方案是只清除需要清除的区块，这就需要具体与游戏的逻辑结合起来。

#使用直线绘制图形

使用canvas中的直线（调用方法lineTo）可以实现很多基础图形的绘制。 按照API的说明，在每次绘制一个新的路径的时候，使用beginPath方法，在绘制完路径后，使用closePath方法即可完成起点到终点由一条直线连接。如果需要填充色，使用fill方法，如需要边缘勾勒，使用stroke方法。
    如下是一个简单的模拟画图板的小应用：

```html

    <!doctype html>  
    <html>  
        <head>  
            <meta charset="utf-8">  
            <title>Canvas</title>  
            <style type="text/css">  
                body {  
                    margin: 0px;  
                    padding: 0px;  
                }  
                #canvas {  
                    margin: 0px;  
                    padding: 0px;  
                    border: 1px solid #000000;  
                }  
            </style>  
        </head>  
        <body>  
            <canvas id="canvas" width="400" height="400">当前浏览器不支持canvas</canvas>  
            <script type="text/javascript" src="utils.js"></script>  
            <script type="text/javascript" src="arrow.js"></script>  
            <script type="text/javascript">  
                window.onload=function(){  
                    var canvas=document.getElementById("canvas");  
                    var context=canvas.getContext("2d");  
                    var mouse=utils.captureMousePosition(canvas);  
                                      
                                    //添加mousedown监听事件，在用户鼠标按下后开始画线，并注册mousemove事件  
                    canvas.addEventListener("mousedown",function(event){  
                        context.beginPath();  
                        context.moveTo(mouse.x, mouse.y);  
                        canvas.addEventListener("mousemove",onMouseMove,false);  
                    },false);  
                                      
                                    //在鼠标移动时划线   
                    function onMouseMove(event){  
                        context.lineTo(mouse.x,mouse.y);  
                        context.stroke();     
                    }  
                                    //在鼠标按键松开后，注销鼠标移动事件  
                    canvas.addEventListener("mouseup",function(event){  
                        canvas.removeEventListener("mousemove",onMouseMove,false);  
                    },false);  
                };  
            </script>  
        </body>  
    </html>  

```

#使用quadraticCurveTo绘制二次贝赛尔曲线
Canvas提供了一系列的方法来绘制曲线，比如quadraticCurveTo(通过起始两个点以及一个控制点来绘制，前两个参数为控制点横纵坐标，后两个参数为终点横纵坐标，使用的是数学上的二次贝赛尔方程)。下面我们来看一下常见的一些使用。


###固定控制点

如下程序，我们实现了一个固定起始点，使用鼠标位置做为控制点，来绘制二次贝赛尔曲线的应用

```html

    <!doctype html>  
    <html>  
        <head>  
            <meta charset="utf-8">  
            <title>Canvas</title>  
        </head>  
        <body>  
            <canvas id="canvas" width="400" height="400">当前浏览器不支持canvas</canvas>  
            <script type="text/javascript" src="utils.js"></script>  
            <script type="text/javascript" src="arrow.js"></script>  
            <script type="text/javascript">  
                window.onload=function(){  
                    var canvas=document.getElementById("canvas");  
                    var context=canvas.getContext("2d");  
                    var mouse=utils.captureMousePosition(canvas);  
                                    //固定两个端点  
                    var x0=100,y0=200,x2=300,y2=200;  
      
                    canvas.addEventListener('mousemove',function(){  
                        //context.clearRect(0,0,canvas.width,canvas.height);  
                                            //指定控制点为鼠标位置  
                        var x1=mouse.x;  
                        var y1=mouse.y;  
                                            //绘制曲线  
                        context.beginPath();  
                        context.moveTo(x0,y0);  
                        context.quadraticCurveTo(x1,y1,x2,y2);  
                        context.stroke();  
                    },false);  
                };  
            </script>  
        </body>  
    </html>  

```

###曲线过定点

之前我们绘制的曲线是控制点确定的曲线，如果我们已知曲线上的一个点（非起始点），则需要通过贝赛尔方程的一些特性来处理。(n次贝赛尔曲线有n+1个控制点，并且贝赛尔曲线位于这些控制点组成的多边形内部。) 

       已知两个端点(x0,y0)与(x2,y2)及曲线上的一个点(x1,y1).则可以得到其控制点的位置为

>x = x1 * 2 - (x0 + x2) / 2;  
y = y1 * 2 - (y0 + y2) / 2;                   

（参见如下文章：

http://learn.gxtc.edu.cn/NCourse/jxcamcad/cadcam/Mains/main4-2.htm
http://www.leeyou.net/UTutorial/show.php?cid=153
http://hi.baidu.com/ggggwhw/blog/item/ffd23d35f313543c5ab5f5ed.html）。

所以，我们只需要修正上述固定控制点的代码，通过曲线上的点来求新的固定点的坐标即可：

>var x1=mouse.x*2-(x0+x2)/2;  
var y1=mouse.y*2-(y0+y2)/2; 

###多点控制的平滑曲线

 下面来看一个复杂一点的问题，如果我们随机有N个点，如何来使用这N个点，利用二次贝赛尔曲线来绘制一条平滑的曲线？最简单的想法就是每三个点一组来绘制一个二次贝赛尔曲线，不难得到如下代码：

```js

                      window.onload=function(){  
    var canvas=document.getElementById("canvas");  
    var context=canvas.getContext("2d");  
    var points=[];  
    var pointNumber=9;  
    //随机生成点  
    for(var i=0;i<pointNumber;i++){  
        points.push({  
            x:Math.random()* canvas.width,  
            y:Math.random()* canvas.height  
        });  
    }                 
    //每三点来绘制一条曲线  
    context.beginPath();  
    context.moveTo(points[0].x,points[0].y);  
    for(var i=1;i< pointNumber; i+=2){  
        context.quadraticCurveTo(points[i].x,points[i].y,points[i+1].x,points[i+1].y);  
    }                 
    context.stroke();  
    //绘制所有给定的点  
    for(var i=0;i<pointNumber;i++){  
        context.moveTo(points[i].x,points[i].y);  
        context.beginPath();  
        context.arc(points[i].x,points[i].y,2,0,Math.PI*2,true);  
        context.closePath();  
        context.fill();  
    }  
    ;  
```

查看结果，会发现并不是想要的效果，除了共用起始点外，所有的二次曲线都是独立分隔的，并不是一条平滑的曲线，如下图：

这是因为使用二次贝赛尔方程来绘制一个多点控制的平滑曲线，不可以每三个已知点为一组依次来绘制曲线，这样绘制出来的每一个二次曲线并不在一个相对坐标系统内。可以从第二个点开始，使用每两个点的中点来做端点，其它点均做为控制点来绘制曲线，如下图：(空心点为已知的给定点，实心点为给定点的中点)

按上面的说明，我们来更新代码:

```js

window.onload=function(){  
    var canvas=document.getElementById("canvas");  
    var context=canvas.getContext("2d");  
    var points=[];  
    var pointNumber=9;  
    var ctrlPoint={x:0,y:0};  
      
    for(var i=0;i<pointNumber;i++){  
        points.push({  
            x:Math.random()* canvas.width,  
            y:Math.random()* canvas.height  
        });  
    }                 
      
    context.beginPath();  
    context.moveTo(points[0].x,points[0].y);  
                            //从第二个点开始，使用之后两点之间的“中点”来做为端点  
                             for(var i=1;i< pointNumber-2; i++){  
        ctrlPoint.x=(points[i].x+points[i+1].x)/2;  
        ctrlPoint.y=(points[i].y+points[i+1].y)/2;  
        context.quadraticCurveTo(points[i].x,points[i].y,ctrlPoint.x,ctrlPoint.y);  
    }     
                             //最后两个点需要特殊处理，无法使用此两点间的“中点”  
    context.quadraticCurveTo(points[i].x,points[i].y,points[i+1].x,points[i+1].y);            
    context.stroke();  
      
      
    for(i=0;i<pointNumber;i++){  
        context.moveTo(points[i].x,points[i].y);  
        context.beginPath();  
        context.arc(points[i].x,points[i].y,5,0,Math.PI*2,true);  
        context.closePath();  
        context.fill();  
    }  
};  

```

###封闭曲线的实现

可以看出，上述代码对于第一个点，最后一个点相关的“中点”都没有使用到。如果我们想利用到这两个点相关的“中点”来构成一个封闭的平滑曲线。那把所有的点均做为控制点来处理，使用它们的“中点”来做为每一个二次贝赛尔曲线的端点，如下代码所示：

```js

window.onload=function(){  
var canvas=document.getElementById("canvas");  
var context=canvas.getContext("2d");  
var points=[];  
var pointNumber=9;  
var ctrlPoint={x:0,y:0};  
var ctrlPoint1={x:0,y:0};  
  
for(var i=0;i<pointNumber;i++){  
    points.push({  
        x:Math.random()* canvas.width,  
        y:Math.random()* canvas.height  
    });  
}                 
  
                            //构造控制点，使用给定点的“中点”来做为曲线的端点  
ctrlPoint1.x=(points[0].x+points[pointNumber-1].x)/2;  
ctrlPoint1.y=(points[0].y+points[pointNumber-1].y)/2;  
context.beginPath();  
context.moveTo(ctrlPoint1.x,ctrlPoint1.y);  
for(var i=0;i< pointNumber-1; i++){  
    ctrlPoint.x=(points[i].x+points[i+1].x)/2;  
    ctrlPoint.y=(points[i].y+points[i+1].y)/2;  
    context.quadraticCurveTo(points[i].x,points[i].y,ctrlPoint.x,ctrlPoint.y);  
}  
                           //封闭曲线  
                            context.quadraticCurveTo(points[i].x,points[i].y,ctrlPoint1.x,ctrlPoint1.y);              
context.stroke();  
  
  
for(i=0;i<pointNumber;i++){  
    context.moveTo(points[i].x,points[i].y);  
    context.beginPath();  
    context.arc(points[i].x,points[i].y,2,0,Math.PI*2,true);  
    context.closePath();  
    context.fill();  
}  

```

注意上面的代码中的i，我们在第一个循环外也使用了i,这是因为JavaScript的变量作用域不是块级的，而是以函数来区分的,如：

```js

console.log(j);          //undefined  
for(var j=0;j<10;j++){  
    console.log(j);      //1~9  
}  
console.log(j);          //10

```

#3.5 渐变 

 Canvas的渐变有两各路 ，线性或径向。在使用gradient时，注意使用createLinearGradient与createRadiusGradient所创建的fillStyle均只在其指定的矩形/圆环区域内生效，如果要fill的图形处于gradient对象之后，则fill后的区域不会出现预料的渐变效果。

如下代码，演示了如何使用渐变：

```js

window.onload=function(){  
var canvas=document.getElementById("canvas");  
var context=canvas.getContext("2d");  
                            //定义纯性渐变  
var point1={x:0,y:0},point2={x:100,y:100};  
var gradient=context.createLinearGradient(point1.x,point1.y,point2.x,point2.y);  
gradient.addColorStop(0,'#ff0000');  
gradient.addColorStop(1,'#00ff00');  
                     //使用线性渐变绘制距形  
context.fillStyle=gradient;  
context.fillRect(0,0,100,100);  
context.fillRect(100,0,200,100);  
                            //定义线性渐变  
var gradient1=context.createLinearGradient(0,100,200,200);  
gradient1.addColorStop(0,'#ff0000');  
gradient1.addColorStop(0.5,'#00ff00');  
gradient1.addColorStop(1,'#0000ff');  
                            //使用线性渐变绘制距形，注意此处渐变区域  
context.fillStyle=gradient1;  
context.fillRect(0,100,100,200);  
                            //定义径向渐变  
var c1 = {x: 300, y: 300, radius: 0};  
var c2 = {x: 300, y: 300, radius: 50};  
                            var gradient2=context.createRadialGradient(c1.x,c1.y,c1.radius,c2.x,c2.y,c2.radius);  
gradient2.addColorStop(0,'#ffff00');  
gradient2.addColorStop(0.5,'#00ffff');  
gradient2.addColorStop(1,'#ff00ff');  
                            //使用径向渐变绘制圆形  
context.fillStyle=gradient2;  
context.arc(300,300,50,0,Math.PI*2,true);  
context.fill();       
;

```

#3.6图片加载

大多数的游戏中的素材都是图片，无论使用单个的图片，还是使用CSS-Sprite方式，都需要将其绘制在Canvas画布上。可以使用动态加载的方式加载图片。
    Canvas提供了一些像素级操作图片的方法getImageData,createImageData与pubImageData。对于每一个像素点，都可以由R,G,B,A四个连续的数字组成。于是，一张图片中所有的点就可以由一个数组来描述，这个数组每四个元素表示一个像素点的值。任意一个像素点在数组中的偏移位置为：

>var offset = (xpos + ypos * imagedata.width) * 4;  

通过对每一个像素的RGBA值的精确处理，可以实现各种效果，如下，实现了一个圣诞节彩喷字体样式的画图板：

```js

window.onload=function(){  
                           //初始化各类参数  
                            var canvas=document.getElementById("canvas");  
var context=canvas.getContext("2d");  
var mouse=utils.captureMouse(canvas);  
var imageData=context.getImageData(0,0,canvas.width,canvas.height);  
var pixels=imageData.data;  
var brush_width=20;  
var brush_destiny=50;  
var brush_color='#ffffff';  
//注册鼠标按下操作：获取随机色  
canvas.addEventListener("mousedown",function(){  
    brush_color = utils.parseColor(Math.random() * 0xffffff, true);   
    canvas.addEventListener("mousemove",onMouseMove,false);  
},false);  
                           //注册鼠标按键松开状态：取消鼠标移动监听事件  
                            canvas.addEventListener("mouseup",function(){  
    canvas.removeEventListener("mousemove",onMouseMove,false);  
},false);  
//鼠标移动事件  
function onMouseMove(){  
    for(var i=0;i<brush_destiny;i++){  
                                           //以鼠标位置为圆心，取得随机的一个点的坐标（三角函数表示)  
                                            var angle=Math.random()*Math.PI*2;  
        var radius=Math.random()*brush_width;  
        var positionX=(mouse.x+Math.cos(angle)*radius)|0;  
        var positionY=(mouse.y+Math.sin(angle)*radius)|0;  
                                            //取得当前随机点在整个画面imageData中的偏移，修正当前像素RGBA色为鼠标按下时指定的色彩  
                                            var offset=(positionX+positionY*imageData.width)*4;  
        pixels[offset] = brush_color >> 16 & 0xff; //red  
        pixels[offset + 1] = brush_color >> 8 & 0xff; //green  
        pixels[offset + 2] = brush_color & 0xff; //blue  
        pixels[offset + 3] = 255; //alpha  
    }  
                                     //将修正过的imageData生效到当前画布  
                                     context.putImageData(imageData,0,0);  
}  
;

```

`此处用到一个工具函数来对色彩进行处理`

```js
utils.parseColor=function(color,toNumber){  
    if(toNumber===true){  
                //将指定的色彩转化为数字值  
        if(typeof color ==='number'){  
            return (color | 0);  
        }  
        if(typeof color === 'string' && color[0]==='#'){  
            color=color.slice(1);  
        }  
        return window.parseInt(color,16);  
    }else{  
                //将输入的数字转换为RGB色彩值  
        if(typeof color === 'number'){  
            color='#'+('00000'+(color | 0).toString(16)).substr(-6);  
        }  
        return color;  
    }  
};

```
[TOC]
#`速度`

运动最基本的属性就是速度。注意这里的速度是物理中所说的速度(Velocity)，它包括大小及方向两部分组成。在动画中，如果我们已知当前一帧对象的位置以及速度，那在下一帧我们就能计算出物体所在的位置。在大多数情况下，速度的大小是按像素/帧为单位的，但实际运行中，由于浏览器的帧率不稳定性，会出现小的差别。如果应用对于统一帧率要求很严格，可以使用其它的方式来处理，之后我们会介绍这方面的知识。 

#向量

物理中我们使用向量来表示速度，向量包括大小和方向两个属性。其大小是一个非负整数。向量是没有位置的，它只能表示在某一方向上大小的改变快慢。两个向量在大小和方向都相同的情况下是相等的。
    对于向量的相加，我们通常会将向量按坐标轴正交分解，之后在每个坐标轴方向上执行对应的加法，最后再将两个坐标轴上的结果进行正交合成，即得到向量相加的结果。


#一维坐标系统下的速度

我们给之前的的Ball类添加vx与vy 来分别表示X轴及Y轴下的速度大小。对象的移动就可以在每一帧开始时给其坐标增加加对应的速度大小来实现。如下：


```js

    window.onload=function(){  
        var canvas=document.getElementById("canvas");  
        var context=canvas.getContext("2d");  
          
        var ball1=new Ball();  
        ball1.vx=1;  
        ball1.x=100;  
          
        (function animationLoop(){  
            window.requestAnimFrame(animationLoop,canvas);  
            context.clearRect(0,0,canvas.width,canvas.height);  
            ball1.x+=ball1.vx;  
            ball1.paint(context);  
        })();  
    };  

```

如上代码所示，每一帧开始时，我们为小球的X坐标ball.x增加了其在X轴上的速度ball.vx,于是就可以实现小球从初始位置一直向右移动的效果。

#二维坐标系统下的速度

 二维坐标下的速度计算非常简单，我们只需要分别对X与Y轴上运动对象的位置属性增加对应坐标轴上运动对象的速度大小即可（如果速度是反向的，就需要减少速度大小）。此时，代码为：

 ```js

 window.onload=function(){  
var canvas=document.getElementById("canvas");  
var context=canvas.getContext("2d");  
  
var ball1=new Ball();  
ball1.vx=1;  
ball1.vy=1;  
ball1.x=100;  
ball1.y=100;  
(function animationLoop(){  
    window.requestAnimFrame(animationLoop,canvas);  
    context.clearRect(0,0,canvas.width,canvas.height);  
    ball1.x+=ball1.vx;  
    ball1.y+=ball1.vy;  
    ball1.paint(context);  
})();  
;  

```

如上代码所示，每一帧开始时，我们为小球的X坐标ball.x增加了其在X轴上的速度ball.vx，同时为小球Y坐标ball.y增加了其在Y轴上的速度ball.vy。这样，在运动中速度正交合并后，就可以实现小球从初始位置开始沿合并方向运动以速度大小移动的效果。

#已知初始方向及大小的速度

前面我们实现的都是已知两个正交坐标轴方向速度大小的运动，但在实际应用中，这种情况很少见，更多的是已知速度的大小及方向的运动。此时，我们就需要使用之前介绍的三角函数。常见的变换如下：

>vx=Math.cos(angle)*V;  
vy=Math.sin(angle)*V;

此时，我们之前的运动小球的代码如下：

```js

window.onload=function(){  
var canvas=document.getElementById("canvas");  
var context=canvas.getContext("2d");  
var angle=45;  
var speed=1;  
  
var ball1=new Ball();  
//注意此处必须执行角度弧度转换  
angle=angle*Math.PI/180;  
ball1.vx=Math.cos(angle)*speed;  
ball1.vy=Math.sin(angle)*speed;  
ball1.x=100;  
ball1.y=100;  
(function animationLoop(){  
    window.requestAnimFrame(animationLoop,canvas);  
    context.clearRect(0,0,canvas.width,canvas.height);  
  
                                    ball1.x+=ball1.vx;  
    ball1.y+=ball1.vy;  
    ball1.paint(context);  
})();  
;  

```

此时就实现了小球从初始位置，以方向45度，大小为1的速度移动的效果。

#鼠标跟随效果

之前，我们实现了一个跟随鼠标位置转到的箭头，在此我们给箭头添加速度，让箭头跟随鼠标移动。首先，需要给箭头添加两个坐标轴方向的速度属性。接着，在每一帧中我们计算出箭头中心到鼠标所在位置的向量，此时箭头的速度给箭头位置添加此向量后即可。代码实现如下：

```js

window.onload=function(){  
var canvas=document.getElementById("canvas");  
var context=canvas.getContext("2d");  
var mouse=utils.captureMousePosition(canvas);  
var speed=5;  
  
var arrow=new Arrow();  
arrow.x=canvas.width/2;  
arrow.y=canvas.height/2;  
  
(function animationLoop(){  
    window.requestAnimFrame(animationLoop,canvas);  
    context.clearRect(0,0,canvas.width,canvas.height);  
                                    //取得变化向量(从箭头位置指向鼠标位置)  
    var dx=mouse.x-arrow.x;  
    var dy=mouse.y-arrow.y;  
    var angle=Math.atan2(dy,dx);  
    arrow.rotation=angle;  
                                    //速度位移更新  
    arrow.vx=Math.cos(angle)*speed;  
    arrow.vy=Math.sin(angle)*speed;  
    arrow.x+=arrow.vx;  
    arrow.y+=arrow.vy;  
    arrow.paint(context);  
})();  
                        };  

```

#速度扩展

除了对于运动对象的位置使用速度来改变，我们也可以对于运动对象的其它属性使用这种方式来进行改变。比如对象的旋转属性，在游戏中就是经常使用到的一个功能。下面我们实现一个对象自旋的功能。

```js

    window.onload=function(){   
                 var canvas=document.getElementById("canvas");   
                 var context=canvas.getContext("2d");   
                 var rotationSpeed=1;   
                 var arrow=new Arrow();   
                 arrow.x=canvas.width/2;   
                 arrow.y=canvas.height/2;   
                 (function animationLoop(){   
                      window.requestAnimFrame(animationLoop,canvas);   
                      context.clearRect(0,0,canvas.width,canvas.height);   
                      //更新箭头旋转属性值   
                      arrow.rotation+=rotationSpeed*Math.PI/180;  
                      arrow.paint(context);   
                  })();   
    };  
```


[TOC]
#加速度

加速度是改变速度大小及方向的一个属性，在物体受力的过程中，会产生加速度来改变速度的大小及方向。加速度的处理与速度的处理非常类似。                            
###一维坐标系统下的加速度

一维坐标系统下加速度的实现很简单，我们仍然使用小球系统来模拟，为小球对象添加X轴与Y轴上的加速度属性。实现起来有两步：初始化加速度值，在每一帧开始时为速度增加加速度的值。如下：

>ball.ax=INITIAL_ACCELERATE_VELOCITY;  
ball.vx+=ball.ax;    //将此句放置于animationLoop中  

###二维坐标系统下的加速度

与二维坐标系统下的速度处理方式相同，二维坐标系统下的加速度处理如下：

    ball.ax=INITIAL_ACCELERATE_VELOCITY_X;  
    ball.ay=INITIAL_ACCELERATE_VELOCITY_Y;  
    ball.vx+=ax;     //将此两句放置于animationLoop中  
    ball.vy+=ay;    

###重力加速度

重力加速度是一种特殊的加速度。对其的处理可以当作一维坐标（Y轴）系统下的加速度来处理：

>    ball.vy+=gravity;       //gravity是重力加速度常量  

###已知初始方向及大小的加速度

前面我们实现的都是已知两个正交坐标轴方向加速度大小的运动，但在实际应用中，这种情况很少见，更多的是已知加速度的大小及方向的运动。此时，我们就需要使用之前介绍的三角函数。常见的变换如下：

>ax=Math.cos(angle)*A;  
ay=Math.sin(angle)*A; 

我们对之前在速度处理中实现的鼠标跟随效果进行改进，在其中引入加速度处理,核心代码实现如下：

```js

window.onload=function(){  
                           //初始化变量  
                            var canvas=document.getElementById("canvas");  
var context=canvas.getContext("2d");  
var mouse=utils.captureMousePosition(canvas);  
var accelerateSpeed=1;  
                            //绘制箭头  
var arrow=new Arrow();  
arrow.x=canvas.width/2;  
arrow.y=canvas.height/2;  
  
(function animationLoop(){  
    window.requestAnimFrame(animationLoop,canvas);  
               context.clearRect(0,0,canvas.width,canvas.height);  
                                    //取得由箭头中心指向鼠标位置的向量方向，并旋转箭头  
    var dx=mouse.x-arrow.x;  
    var dy=mouse.y-arrow.y;  
    var angle=Math.atan2(dy,dx);  
    arrow.rotation=angle;  
                                    //通过三角函数求得加速度，并对应改变速度及位置  
                                    arrow.vx+=Math.cos(angle)*accelerateSpeed;  
    arrow.vy+=Math.sin(angle)*accelerateSpeed;  
    arrow.x+=arrow.vx;  
    arrow.y+=arrow.vy;  
  
    arrow.paint(context);  
})();  
;  

```

 运行代码，会发现效果很像一个水平摆。

 ###加速度实例——宇宙飞船

 加速度一个很好的实例就是飞船的起飞和降落。我们会逐渐实现一个简易的飞船。如下，是一个用三角形构成的飞船模型：

 ```js

     function Ship(){  
            //定义飞船属性  
            this.x=0;  
        this.y=0;  
            this.vx=0;  
            this.vy=0;  
            this.rotation=0;  
        this.width=25;  
        this.height=20;  
        this.showFlame=false;  
    }  
      
    Ship.prototype.paint=function(context){  
        context.save();  
            //定义画面属性  
            context.translate(this.x,this.y);  
        context.rotate(this.rotation);  
        context.lineWidth=1;  
        context.strokeStyle='#ffffff';  
            //绘制飞船  
            context.beginPath();  
        context.moveTo(10,0);  
        context.lineTo(-10,10);  
        context.lineTo(-5, 0);  
        context.lineTo(-10, -10);  
        context.lineTo(10, 0);  
        context.stroke();  
            //绘制喷火     
            if(this.showFlame){  
            context.beginPath();  
            context.moveTo(-7.5, -5);  
            context.lineTo(-15, 0);  
            context.lineTo(-7.5, 5);  
            context.stroke();  
        }  
        context.restore();    
    };  

```

以上代码实现了一个简单的飞船模型，飞船在加速时会喷火，如下图：

```html

    <!DOCTYPE html>  
    <html>  
        <head>  
            <meta charset="utf-8" />  
            <title>Arrow</title>  
            <style type="text/css">  
                #canvas {  
                    border-bottom: 1px solid #ffffff;  
                    background-color: #000000;  
                }  
            </style>  
        </head>  
        <body>  
            <canvas id="canvas" width="400" height="400"></canvas>  
            <script type="text/javascript" src="utils.js"></script>  
            <script type="text/javascript" src="ship.js"></script>  
            <script type="text/javascript">  
                window.onload=function(){  
                    var canvas=document.getElementById("canvas");  
                    var context=canvas.getContext("2d");  
      
                    var ship=new Ship();  
                    ship.x=canvas.width/2;  
                    ship.y=canvas.height/2;  
      
                    var vr=0;  
                    var f=0;  
                    //处理键盘事件  
                    window.addEventListener("keydown",function(event){  
                        console.log(event.keyCode);  
                        switch(event.keyCode){  
                            case 37:  //左，逆时针转  
                                vr=-3;  
                                break;  
                            case 39:  //右，顺时针转  
                                vr=3;  
                                break;  
                            case 38:  //上，加速  
                                f=0.05;  
                                ship.showFlame=true;  
                                break;  
                        }  
                    });  
                   //按键松开时恢复相关属性为默认值  
                    window.addEventListener("keyup",function(event){  
                        ship.showFlame=false;  
                        vr=0;  
                        f=0;  
                    },false);  
                     
                    (function animationLoop(){  
                        window.requestAnimFrame(animationLoop,canvas);  
                        context.clearRect(0,0,canvas.width,canvas.height);  
                        //通过角度和大小来确定加速度，从而确定飞船的速度与位置  
                        ship.rotation+=vr*Math.PI/180;  
                        ship.vx+=Math.cos(ship.rotation)*f;  
                        ship.vy+=Math.sin(ship.rotation)*f;  
                        ship.x+=ship.vx;  
                        ship.y+=ship.vy;  
                        ship.paint(context);  
                    })();  
                };  
            </script>  
        </body>  
    </html>  

    ```

如此，实现了一个利用加速度的飞船模型，左右箭头是用来控制旋转方向的，上箭头是用来加速的。但很快飞船就跑出画布了，之后我们会介绍如何来进行边界控制。


#`边界控制与摩擦力`        

在大多数的游戏设计中，会有环境边界控制来帮助我们保证画布中的对象在运动的过程中不会脱离画面。同时，对象的运动环境很少会是真空的情况，所以就会存在着摩擦力阻碍物体的速度变化。

#环境边界控制

如果我们关注的运动对象在移动的过程中消失在了视窗之外，我们有两大类的选择：一种是将对象重新移动到当前的视窗中或者不再关注此对象，另一种方式是使当前的视窗跟随运动对象移动。在程序实现上，这两类很相近。下面我们主要针对第一类来进行分析。

###设置边界

运动对象的运动边界可以是整个Canvas视窗，也可以只是其中的一小块，在实现上没本质上的差异。我们假设边界为整个Canvas视窗。即：

```js

var left = 0,  
top = 0,  
right = canvas.width,  
bottom = canvas.height; 

```

很轻易地得到边界处理的模板代码：

```js

    if (ball.x > canvas.width) {  
    // do something  
    } else if (ball.x < 0) {  
    // do something  
    }  
    if (ball.y > canvas.height) {  
    // do something  
    } else if (ball.y < 0) {  
    // do something  
    }  

```

在对超出边界对象的处理时，我们可以将这个对象清理了，或者将其对象回收放入对象池中使用，或者将对象重新放置在画布的另一侧让其继续运动，或者使对象进行反弹。


###清理对象    

以小球系统为例，假设我们有大量小球对象，这些小球被放置在一个数组中并初始化。如果小球运动时超出边界，则将此对象从小球数组中清理。如下：

```js

    if (ball.x – ball.radius > canvas.width ||  
                           ball.x + ball.radius < 0 ||  
       ball.y – ball.radius > canvas.height ||  
                              ball.y + ball.radius < 0) {  
          balls.splice(balls.indexOf(ball), 1);  
    }  

```    

但如果我们在之前的小球系统中加入上述代码后运行就会发现问题，下面两幅图清晰地反映了这个问题及解决方式：

第一幅图我们可以看到，小球的一半已经进入了边缘，此时我们的程序才检测出小球运动超出了画布。如第二幅图所示，我们需要特殊处理，在小球的球心离边缘的距离小于其半径时，就需要进行边缘越界处理。如下：

```js

    if (ball.x – ball.radius > canvas.width ||  
                          ball.x + ball.radius < 0 ||  
       ball.y – ball.radius > canvas.height ||  
                           ball.y + ball.radius < 0) {  
              balls.splice(balls.indexOf(ball), 1);  
    }  

```

以下为上述原理的一个完整实现的例子：

```js


    window.onload=function(){  
                    var canvas = document.getElementById('canvas');  
                    var context = canvas.getContext("2d");  
                    var balls=[];  
                    var ballNumbers=10;  
                   //初始化小球  
                    for(var ball,i=0;i<ballNumbers;i++){  
                        ball=new Ball(20);  
                        ball.id="ball"+i;  
                        ball.x=Math.random()*canvas.width;  
                        ball.y=Math.random()*canvas.height;  
                        ball.vx=Math.random()*2-1;  
                        ball.vy=Math.random()*2-1;  
                        balls.push(ball);  
                    }  
                   //绘制小球  
                    function draw(ball,pos){  
                        //速度处理  
                        ball.x+=ball.vx;  
                        ball.y+=ball.vy;  
                        //边缘检测  
                        if(ball.x-ball.radius > canvas.width||  
                            ball.x+ball.radius < 0||  
                            ball.y+ball.radius < 0|  
                            ball.y-ball.radius > canvas.height){  
                            balls.splice(pos,1);  
                        }  
                        ball.draw(context);  
                    }  
                    //帧处理  
                    (function drawFrame(){  
                        window.requestAnimFrame(drawFrame,canvas);  
                        context.clearRect(0,0,canvas.width,canvas.height);  
                        console.log(balls.length);  
                        var i=balls.length;  
                        while(i--){  
                            draw(balls[i],i);  
                        }  
                    })();  

```                    

###对象回收

对于越界运动对象的回收处理与上面介绍的清理方式非常相似，只需要把清理的过程换成对象运动状态的初始化即可。如下我们以一个类喷泉式的示例来演示其原理：

```js

    window.onload=function(){  
                    var canvas = document.getElementById('canvas');  
                    var context = canvas.getContext("2d");  
                    var balls=[];  
                    var ballNumbers=300;  
                    var gravity=0.5;  
                   //初始化小球  
                    for(var ball,i=0;i<ballNumbers;i++){  
                        ball=new Ball(2,Math.random()*0xffffff);  
                        ball.x=canvas.width/2;  
                        ball.y=canvas.height;  
                        ball.vx=Math.random()*2-1;  
                        ball.vy=Math.random()*-10-10;  
                        balls.push(ball);  
                    }  
                   //绘制小球  
                    function draw(ball){  
                       //重力及速度处理  
                        ball.vy+=gravity;  
                        ball.x+=ball.vx;  
                        ball.y+=ball.vy;  
                        //边缘处理  
                        if(ball.x-ball.radius > canvas.width||  
                            ball.x+ball.radius < 0||  
                            ball.y+ball.radius < 0|  
                            ball.y-ball.radius > canvas.height){  
                            ball.x=canvas.width/2;  
                            ball.y=canvas.height;  
                            ball.vx=Math.random()*2-1;  
                            ball.vy=Math.random()*-10-10;  
                        }  
                        ball.draw(context);  
                    }  
                   //帧处理  
                    (function animationLoop(){  
                        window.requestAnimFrame(animationLoop,canvas);  
                        context.clearRect(0,0,canvas.width,canvas.height);  
                        console.log(balls.length);  
                        for(var i=0;i<ballNumbers;i++){  
                            draw(balls[i]);  
                        }  
                    })();  
                };  

```                
如上代码，每一帧中，我们会对所有的小球对象进行绘制。在此定义了一个draw函数用来处理越界及绘制功能。首先对重力加速度进行了处理，接着对于两个坐标轴的速度进行了处理，然后检测小球是否越界（如果越界，则将其运动状态初始化），最后绘制小球。整体效果图如下：

###画布扩展

画布扩展的实现很简单，如果运动对象超出画布的右侧，则将其移动到画面的左侧（反之亦然），如果运动对象超出画布的上方，则将其移动到画面的下侧（反之亦然）。其实现原理与上述的对象回收类似。我们对之前介绍过的键盘控制飞船应用进行改造，只需要在其帧处理函数animationLoop中ship.paint(context)前加入如下的边界处理代码即可：

```js

    if(ship.x-ship.width/2>right){  
        ship.x=left-ship.width/2;  
    }else if(ship.x+ship.width<left){  
        ship.x=right+ship.width/2;  
    }else if(ship.y+ship.height/2<top){  
        ship.y=bottom+ship.height/2;  
    }else if(ship.y-ship.height/2>bottom){  
        ship.y=top-ship.height/2;  
    }  

```    

###反弹

反弹的处理原理很简单，在运动对象碰到边界后，我们将其放置到与边缘紧貼的位置，之后将其方向反向即可（因为边界是水平或竖直的，我们只需要考虑一个方向上的分速度反向，如果碰撞面是倾斜的，就需要进行坐标系统的旋转，这个之后会专门介绍）。
     仍然拿小球系统来分析，只需要在每一帧绘制小球前执行以下代码即可：

```js

    if (ball.x + ball.radius > right) {  
           ball.x = right - ball.radius;  
           vx *=bounce;  
    } else if (ball.x - ball.radius < left) {  
           ball.x = left + ball.radius;  
           vx *=bounce;  
    }  
    if (ball.y + ball.radius > bottom) {  
           ball.y = bottom - ball.radius;  
           vy *= bounce;  
    } else if (ball.y - ball.radius < top) {  
           ball.y = top + ball.radius;  
           vy *= bounce;  
    }  

```         

其中的bounce是一个常量，如果是完全弹性碰撞，则bounce=-1。如果在反弹时有损耗,可以将其值根据实际情况进行调整。此处我们的碰撞处理是最简单的处理方式，如果运动物体的速度非常快，那其效果会与我们预想的有一些偏差，如下面两幅图的对比就可以看出差异。


#摩擦力

在实际环境中，运动对象在运动时会有摩擦力阻止其运动。对于摩擦力的处理有两种方式，下面仍以小球系统为例分别介绍。

###理论方法

摩擦力是用来减少对象速度的力。所以，其方向是与速度方向相反的。按前面介绍的速度与三角函数方面的理论，我们可以得到速度为：

    var  speed=Math.sqrt(ball.vx*ball.vx+ball.vy*ball.vy);  
    var  angle=Math.atan2(ball.vy,ball.vx);  

接下来，我们就可以从速度中减去摩擦力产生的速度减少常数值。但要注意，在速度减少到已经小于摩擦力产生的速度减少常数时，我们就不需要再给速度减去摩擦力产生的速度常数了，否则就会产生反向的速度，此时只需要将速度置零即可。    


```js

if(speed>friction){  
    speed-=friction;  
}else{  
    speed=0;  
}  
ball.vx=speed*Math.cos(angle);  
ball.vy=speed*Math.sin(angle); 

```

上述代码中的friction为摩擦力产生的速度减少常数。我们只需要将上述代码放入帧函数animationLoop中小球绘制前，就可以为系统添加摩擦力处理了。

###简易方案

从前面的理论处理方法，我们可以看到，一个确定的系统，我们只需要给正交分解后的各个坐标轴上分速度持续地乘以一个速度衰减常数（0到1之间），这样速度会逐渐减少到无限接近0。精确到一定程度，速度已经小到用户无法分辨。
具体实现时，只需要将如下两行代码放入帧函数animationLoop中小球绘制前即可：

    ball.vx*=friction;  
    ball.vy*=friction; 

有时候，为了优化系统性能。我们可以对当前的速度进行判断，如果小于一个指定常数，则不进行速度处理，如： 

    if(Math.abs(ball.vx)>0.0001){  
        ball.vx*=friction;  
    }     

###实例对比

我们对之前的两种方式，在一个系统中进行对比。代码如下：

```js

    window.onload=function(){  
                    var canvas = document.getElementById('canvas');  
                    var context = canvas.getContext("2d");  
                    //使用理论方式运算  
                    var friction=0.01;  
                    //使用简易方式计算  
                    var friction2=0.992;  
                   //实例化并设置初始值  
                    var ball=new Ball();  
                    var ball2=new Ball();  
                    ball2.color='#00ff00';  
                    ball.x=ball2.x=canvas.width/2;  
                    ball.y=ball2.y=canvas.height/2;  
                    ball.vx=ball2.vx=Math.random()*10-5;  
                    ball.vy=ball2.vy=Math.random()*10-5;  
                     
                    (function drawFrame(){  
                        window.requestAnimFrame(drawFrame,canvas);  
                        context.clearRect(0,0,canvas.width,canvas.height);  
                        //理论方式处理第一个小球，先球合速度，再减去摩擦速度，再分解小球分速度与位置  
                        var speed=Math.sqrt(ball.vx*ball.vx+ball.vy*ball.vy);  
                        var angle=Math.atan2(ball.vy,ball.vx);  
                        if(speed>friction){  
                            speed-=friction;  
                        }else{  
                            speed=0;  
                        }  
                        ball.vx=Math.cos(angle)*speed;  
                        ball.vy=Math.sin(angle)*speed;  
                        ball.x+=ball.vx;  
                        ball.y+=ball.vy;  
                        ball.draw(context);  
                       //直接乘以摩擦常数  
                        ball2.vx*=friction2;  
                        ball2.vy*=friction2;  
                        ball2.x+=ball2.vx;  
                        ball2.y+=ball2.vy;  
                        ball2.draw(context);  
                    })();  
                };  

```                

#`用户交互——移动物体`

游戏的核心在于交互，很多时候需要用户动手来操作游戏对象，很基本的一个操作就是移动物体。接下来我们会介绍如何拖动物体，在画布上扔物体等。

#选择与释放对象

使用鼠标对物体的拖拽操作主要有三个步骤——鼠标进入物体范围并按下，鼠标移动及鼠标释放。这涉及到三个鼠标事件：mousedown,mousemove,mouseup。我们按此思路，仍旧以前面介绍的小球系统来实现。
        首先需要检测到鼠标是否进入到小球中，为了简化处理，我们把小球看成一个与其外接矩形等效的图形。先得到小球在画布中所占据的位置。如下代码：

```js

    ball.prototype.getBounds=function(){  
        return { x: ball.x-ball.radius,  y: ball.y-ball.radius,  
              width: 2*ball.radius,  height: 2*ball.radius };  
    }  

```            

如上，得到了小球外接矩形的左上端点及长宽。接下来，我们就需要来查看鼠标是否进入小球，抽象出来就是点是否在当前的矩形中，在其我们使用集合思想，取其对立事件就很容易处理。如下代码：

```js

    utils.containsPoint = function (rect, x, y) {  
            return !(x < rect.x || x > rect.x + rect.width ||  
                         y < rect.y || y > rect.y + rect.height);  
    };  

```    

很明白地看到，我们先取得点不在小球的四种情况，然后取其对立事件即为点在小球内。于是很容易就实现：

```js

    window.onload=function(){  
                var canvas=document.getElementById("canvas");  
                var context=canvas.getContext("2d");  
                var mouse=utils.captureMouse(canvas);  
                 
                var ball=new Ball();  
                ball.x=canvas.width/2;  
                ball.y=canvas.height/2;  
                ball.draw(context);  
               //鼠标按键按下事件  
                canvas.addEventListener("mousedown",function(event){  
                    if(utils.containsPoint(ball.getBounds(),mouse.x,mouse.y)){  
                        console.log("===[mousedown]===in ball");  
                    }else{  
                        console.log("===[mousedown]===out ball");  
                    }  
                },false);  
               //鼠标按键释放事件  
                canvas.addEventListener("mouseup",function(event){  
                    if(utils.containsPoint(ball.getBounds(),mouse.x,mouse.y)){  
                        console.log("***[mouseup]===in ball");  
                    }else{  
                        console.log("***[mouseup]===out ball");  
                    }  
                },false);  
               //鼠标移动事件  
                canvas.addEventListener("mousemove",function(event){  
                    if(utils.containsPoint(ball.getBounds(),mouse.x,mouse.y)){  
                        console.log("###[mousemove]###in ball");  
                    }else{  
                        console.log("###[mousemove]###out ball");  
                    }  
                })  
            };  

```            

#拖动对象

有了上面的实践基础，实现拖动非常容易，只需要在鼠标移动时让小球的位置与鼠标位置相同即可。如下代码：

```js

    window.onload=function(){  
                    var canvas=document.getElementById("canvas");  
                    var context=canvas.getContext("2d");  
                    var mouse=utils.captureMouse(canvas);  
                     
                    var ball=new Ball(40);  
                    ball.x=canvas.width/2;  
                    ball.y=canvas.height/2;  
                    ball.draw(context);  
                   //小球跳动偏差处理  
                    var offset_fix_x=0;  
                    var offset_fix_=0;  
                   //鼠标按下时检测是否位于小球内部，如果位于，则注册移动事件处理函数  
                    canvas.addEventListener("mousedown",function(event){  
                        if(utils.containsPoint(ball.getBounds(),mouse.x,mouse.y)){  
                            offset_fix_x=mouse.x-ball.x;  
                            offset_fix_y=mouse.y-ball.y;  
                            canvas.addEventListener("mousemove",onMouseMove,false);  
                            canvas.addEventListener("mouseup",onMouseUP,false);  
                        }  
                    },false);  
                    //鼠标按键释放时的操作  
                    function onMouseUP(){  
                        canvas.removeEventListener("mouseup",onMouseUP,false);  
                        canvas.removeEventListener("mousemove",onMouseMove,false);  
                    }  
                   //鼠标移动时小球跟随鼠标  
                    function onMouseMove(event){  
                        ball.x=mouse.x-offset_fix_x;  
                        ball.y=mouse.y-offset_fix_y;  
                    }  
                     
                    (function drawFrame(){  
                        window.requestAnimFrame(drawFrame,canvas);  
                        context.clearRect(0,0,canvas.width,canvas.height);  
                         
                        ball.draw(context);  
                    })();  
                };  

```                

很容易就实现了小球移动的功能。注意，offset_x与offset_y是为了用来处理在小球内部我们快速点击小球边缘产生的小球跳动问题。通过记录鼠标按下时鼠标与小球中心的偏差距离，在鼠标移动时固定处理这个偏差，就能避免跳动。

###拖动移动中的对象

如果需要对正在移动中的对象进行拖拽动作，原理和前面介绍的静止的对象拖拽一样，但需要注意，我们必须处理小球在鼠标点击后的状态，将此时小球的速度置0，否则我们鼠标在点住小球后，小球会继续沿其之前的速度运动，这样很难进行拖拽操作。如下代码：

```js

    window.onload=function(){  
                    var canvas=document.getElementById("canvas");  
                    var context=canvas.getContext("2d");  
                    var mouse=utils.captureMouse(canvas);  
                    var left=0,top=0,right=canvas.width,bottom=canvas.height,isMouseDown=false;  
                    var ball=new Ball(40);  
                    //跳动偏差处理  
                    var fix_offset_jump_x=fix_offset_jump_y=0;  
                   //小球移动状态初始化  
                    ball.x=canvas.width/2;  
                    ball.y=canvas.height/2;  
                    ball.vx=Math.random()*10-5;  
                    ball.vy=-10;  
                    bounce=-0.7;  
                    gravity=0.2;  
                    //鼠标按下时检测是否位于小球内部，如果位于，则注册移动事件处理函数  
                    canvas.addEventListener("mousedown",function(){  
                        if(utils.containsPoint(ball.getBounds(),mouse.x,mouse.y)){  
                            isMouseDown=true;  
                            //如果鼠标在小球内部，则使得小球静止  
                            ball.vx=0;  
                            ball.vy=0;  
                            fix_offset_jump_x=mouse.x-ball.x;  
                            fix_offset_jump_y=mouse.y-ball.y;  
                            canvas.addEventListener("mousemove",onMouseMove,false);  
                            canvas.addEventListener("mouseup",onMouseUP,false);  
                        }  
                    },false);  
                     
                    function onMouseUP(){  
                        isMouseDown=false;  
                        canvas.removeEventListener("mousemove",onMouseMove,false);  
                        canvas.removeEventListener("mouseup",onMouseUP,false);  
                    }  
                     
                    function onMouseMove(){  
                        ball.x=mouse.x-fix_offset_jump_x;  
                        ball.y=mouse.y-fix_offset_jump_y;  
                    }  
                   //边缘检测，碰撞处理  
                    function checkBoundary(){  
                        ball.vy+=gravity;  
                        ball.x+=ball.vx;  
                        ball.y+=ball.vy;  
                        if(ball.y-ball.radius<top){  
                            ball.y=ball.radius+top;  
                            ball.vy*=bounce;  
                            console.log(ball.vy);  
                        }else if(ball.y+ball.radius>bottom){  
                            ball.y=bottom-ball.radius;  
                            ball.vy*=bounce;  
                        }  
                        if(ball.x-ball.radius<left){  
                            ball.x=ball.radius+left;  
                            ball.vx*=bounce;  
                        }else if(ball.x+ball.radius>right){  
                            ball.x=right-ball.radius;  
                            ball.vx*=bounce;  
                        }         
                    }  
                     
                    (function drawFrame(){  
                        window.requestAnimFrame(drawFrame,canvas);  
                        context.clearRect(0,0,canvas.width,canvas.height);  
                         
                        if(!isMouseDown){  
                            checkBoundary();  
                        }     
                        ball.draw(context);  
                    })();  
                };  

```

###投掷对象

对于对象的投掷动作看似复杂，其实结合之前的拖拽动作，它的实现就非常简单。假设我们把一个静止的小球在一帧中从原始位置水平移动了10像素后松开鼠标，即实现了扔的动作，那么我们就认为此时小球被以10像素/ 帧的速度水平投掷出来。即

    ball.vx=ball.x-lastX;  
    ball.vy=ball.y-lastY;  

于是，我们对移动中的小球进行投掷动作，代码如下：

```js

    window.onload=function(){  
                    var canvas=document.getElementById("canvas");  
                    var context=canvas.getContext("2d");  
                    var mouse=utils.captureMouse(canvas);  
                    //定义系统环境变量  
                    var top=0,left=0,right=canvas.width,left=0,bottom=canvas.height;  
                    var fix_mouse_drag_offset_x=0;  
                    var fix_mouse_drag_offset_y=0;  
                    var bounce=-0.7;  
                    var gravity=0.2;  
                    var isMouseDown=false;  
                    var oldX=oldY=0;  
      
                   //初始化小球  
                    var ball=new Ball(40);  
                     
                    ball.x=canvas.width/2;  
                    ball.y=canvas.height/2;  
                     
                    ball.vx=Math.random()*10-5;  
                    ball.vy=-10;  
                    //鼠标按下时检测鼠标是否位于小球内部  
                    canvas.addEventListener("mousedown",function(){  
                        if(utils.containsPoint(ball.getBounds(),mouse.x,mouse.y)){  
                            isMouseDown=true;   
                            //小球跳动处理  
                            fix_mouse_drag_offset_x=mouse.x-ball.x;  
                            fix_mouse_drag_offset_y=mouse.y-ball.y;  
                            //将小球置于静止状态  
                            oldX=ball.x;  
                            oldY=ball.y;  
                            mouse.vx=mouse.vy=0;  
                            canvas.addEventListener("mousemove",onMouseMove,false);  
                            canvas.addEventListener("mouseup",onMouseUp,false);  
                        }  
                    },false);  
                     
                    function onMouseMove(){  
                        ball.x=mouse.x-fix_mouse_drag_offset_x;  
                        ball.y=mouse.y-fix_mouse_drag_offset_x;  
                    }  
                     
                    function onMouseUp(){  
                        isMouseDown=false;  
                        canvas.removeEventListener("mousemove",onMouseMove,false);  
                        canvas.removeEventListener("mouseup",onMouseUp,false);  
                    }  
                   //计算小球被投掷后的速度  
                    function trackVelocity(){  
                        ball.vx=ball.x-oldX;  
                        ball.vy=ball.y-oldY;  
                        oldX=ball.x;  
                        oldY=ball.y;  
                    }  
                   //边缘检测，碰撞出理  
                    function checkBoundary(){  
                        ball.vy+=gravity;  
                        ball.x+=ball.vx;  
                        ball.y+=ball.vy;  
                         
                        if(ball.x-ball.radius<left){  
                            ball.x=left+ball.radius;  
                            ball.vx*=bounce;  
                        }else if(ball.x+ball.radius>right){  
                            ball.x=right-ball.radius;  
                            ball.vx*=bounce;  
                        }  
                         
                        if(ball.y-ball.radius<top){  
                            ball.y=top+ball.radius;  
                            ball.vy*=bounce;  
                        }else if(ball.y+ball.radius>bottom){  
                            ball.y=bottom-ball.radius;  
                            ball.vy*=bounce;  
                        }  
                    }  
                     
                    (function drawFrame(){  
                        window.requestAnimFrame(drawFrame,canvas);  
                        context.clearRect(0,0,canvas.width,canvas.height);  
                        //鼠标按下时，进行投掷处理，否则进行边缘检测及碰撞处理  
                        if(!isMouseDown){  
                            checkBoundary();     
                        }else{  
                            trackVelocity();  
                        }  
                        ball.draw(context);  
                    })();  
                     
                };  

```                

#`缓冲和弹跳`

 下面我们来介绍一下很常用的缓冲和弹跳的处理。在我们实现复杂运动时，这两种技术会处理大多种的情况。缓冲与弹跳非常均是用来处理将一个对象从已知起点移动到给定终点的技术——缓冲是指对象滑动到目标位置并停止，而弹跳是指对象做有摩擦力的弹簧振子运动。它们有一些共同点：

 -已知初始位置与目标位置
 -运动参数与距离成正相关

 具体原理是缓冲的速度大小与距离成正相关，而弹跳的加速度大小与距离成正相关。

 #缓冲处理

 缓冲有两大类，缓冲进入到某一种与缓冲离开某一点;同时还有一些具体的运动属性，如以正弦形式缓冲，以弹跳形式缓冲等。我们主要讨论缓冲离开某点的实现，其它的后面会做简单介绍。

 ###简单缓冲 

 简单缓冲很容易理解，下面来简单描述其实现。假设我们想把一个对象在多帧时间之内从A移动到B。我们可以计算A，B两点间的角度与距离，对速度进行正交分解，之后在每一帧的动画中重新绘制当前对象到新位置，等对象到达B点时，停止移动对象。

       上面的方案很容易实现，但如果我们想让对象移动得更自然一些，这个方案就不对了。因为它指定了对象以给定的速度在运动，到达终点时立即停止，这只适合于前面我们介绍的碰撞。我们想要的是带缓冲的实现，在这种情况下，开始的运动速度非常快，随着逐渐接近目标，速度线性地减小，当到达目标位置时，速度变为0。这种简单缓冲有一种非常容易实现的逼近方案：
    1. 设定一个数值（缓冲系统）用来模拟逼近我们的缓冲运动，此值与摩擦系数类似，在0和1之间。
    2. 决定目标位置
    3. 计算起点到终点的距离
    4. 用上面设定的缓冲系数值乘以我们得到的距离，此即当前运动对象的速度
    5. 在每一帧以上面得到的速度来确定物体的速度
    6. 重复上述3~5步。
上面我们指定的缓冲系数可以视为距离的摩擦系数，缓冲系数越接近1，瞬时速度也越大。按上面的描述，我们仍然以小球模型来实现一个简单缓冲的例子。

```html

    <!doctype html>  
    <html>  
        <head>  
            <meta charset="utf-8">  
            <title>缓冲处理</title>  
            <style type="text/css">  
                body {  
                    margin: 0px;  
                    padding: 0px;  
                }  
      
                canvas {  
                    margin: 0px;  
                    padding: 0px;  
                    border: 1px solid #000;   
                }  
            </style>  
        </head>  
        <body>  
            <canvas id="canvas" width="600" height="400"></canvas>  
            <script type="text/javascript" src="utils.js"></script>  
            <script type="text/javascript" src="ball.js"></script>  
            <script type="text/javascript">  
                window.onload=function(){  
                    //初始化环境参数  
                    var canvas=document.getElementById("canvas");  
                    var context=canvas.getContext("2d");  
                    //设置缓冲系数  
                    var EASING=0.1;  
                    //创建小球实例  
                    var ball=new Ball(40);  
                    ball.x=0;  
                    ball.y=0;  
      
                    (function animationLoop(){  
                        window.requestAnimFrame(animationLoop,canvas);  
                        context.clearRect(0,0,canvas.width,canvas.height);  
                        //利用缓冲公式，得到正交分解后的瞬时速度  
                        ball.vx=(canvas.width/2-ball.x)*EASING;  
                        ball.vy=(canvas.height/2-ball.y)*EASING;  
                        //更新当前帧小球位置并绘制  
                        ball.x+=ball.vx;  
                        ball.y+=ball.vy;  
                        ball.paint(context);  
                    })();  
      
                };  
            </script>  
        </body>  
    </html>  
    </html>  
```    
很简单吧？那结合之前我们介绍过的拖动对象，我们如果把对象拖到一个位置，让对象缓冲运动来原始位置。实现也非常简单，如下：

```js

 window.onload=function(){  
//初始化环境参数  
var canvas=document.getElementById("canvas");  
var context=canvas.getContext("2d");  
//设置缓冲系数  
var EASING=0.1;  
var mouse=utils.getMousePosition(canvas);  
//创建小球实例  
var ball=new Ball(40);  
ball.x=canvas.width/2;  
ball.y=canvas.height/2;  
  
//注册鼠标按下事件，检测鼠标是否位于小球内部  
canvas.addEventListener("mousedown",function(event){  
    if(utils.containsPoint(mouse.x,mouse.y,ball.getBounds())){  
        console.log("inner");  
        ball.isDragged=true;  
    }  
},false);  
//注册鼠标移动事件，在鼠标位于小球内时拖动小球  
canvas.addEventListener("mousemove",function(event){  
    if(ball.isDragged){  
        ball.x=mouse.x;  
        ball.y=mouse.y;  
    }  
},false);  
//注册鼠标抬起事件  
canvas.addEventListener("mouseup",function(event){  
    ball.isDragged=false;  
},false);  
  
(function animationLoop(){  
    window.requestAnimFrame(animationLoop,canvas);  
    context.clearRect(0,0,canvas.width,canvas.height);  
    //在小球未拖动时处理缓冲移动  
    if(!ball.isDragged){  
        //利用缓冲公式，得到正交分解后的瞬时速度  
        ball.vx=(canvas.width/2-ball.x)*EASING;  
        ball.vy=(canvas.height/2-ball.y)*EASING;  
        //更新当前帧小球位置并绘制  
        ball.x+=ball.vx;  
        ball.y+=ball.vy;  
    }  
  
    ball.paint(context);  
})();  
  
;  
```

上面的实现其实有很大的性能优化余地。当运动对象已经到达目标位置后，我们的程序还在重复计算对象的速度，重绘界面。只需要添加以下约束即可：

    if (ball.x === targetX && ball.y === targetY) {  
        //具体运动代码  
    }  

 但其实上面的要求相当苛刻，在芝诺悖论中就描述了相关的问题（http://zh.wikipedia.org/wiki/芝诺悖论） 。在工程上我们可以找到简单的逼近方案，下面的代码很清晰地给出了结论：    

 ```js

 var position = 0,  
target = 100;  
for (var i = 0; i < 20; i++) {  
    console.log(i + ": " + position);  
    position += (target - position) * 0.5;  
} 

```

可以看到，在最后一次输出时，position的值已经是99.99990463256836了。这与我们的结果已经非常接近了。我们可以根据缓冲系数得到一个次数，来进行性能优化。当然，在canvas游戏开发中，由于我们的最小单位是像素，所以在工程实现上可以有更简单的逼近方案，如下：

```js

    var animationFlag=null;  
    (function drawFrame () {  
           animationFlag = window.requestAnim(drawFrame, canvas);  
           context.clearRect(0, 0, canvas.width, canvas.height);  
            var dx = targetX – ball.x;  
            //距离一像素以内时，停止处理  
            if (Math.abs(dx) < 1) {  
                ball.x = targetX;  
                window.cancelRequestAnimationFrame(animRequest);  
            } else {  
                 var vx = dx * EASING;  
                 ball.x += vx;  
            }  
            ball.draw(context);  
    }());  

```    

对于终点是动态确定的情形，也很容易实现，结合之前我们实现的鼠标位置获取，我们用鼠标位置来当作终点。如下代码：


```js

    window.onload = function () {  
           var canvas = document.getElementById('canvas'),  
           var context = canvas.getContext('2d'),  
           var mouse = utils.getMousePosition(canvas),    
           var ball = new Ball(),  
           var EASING = 0.05;  
             
            (function animationLoop () {  
                 window.requestAnimFrame(animationLoop, canvas);  
                  context.clearRect(0, 0, canvas.width, canvas.height);  
                  //将鼠标位置设动态设定为终点  
                  var vx = (mouse.x - ball.x) * EASING,  
                  vy = (mouse.y - ball.y) * EASING;  
                  ball.x += vx;  
                  ball.y += vy;  
                  ball.draw(context);  
           }());  
    };  

```    

###缓冲的使用场景

说了这么多，你可能以为缓冲只能使用到运动动画中。其实不然，它的使用场景非常丰富，我们可以对指定对象的多个属性变化来使用缓冲技术。

-角度变化的缓冲

很容易理解，起始位置只是换成了角度而已。如下实现：

    rotation += (targetRotation - rotation) * easing;  
    arrow.rotation = rotation * Math.PI / 180;  

-颜色变化的缓冲（渐变） 

使用缓冲方式可以更加逼真地模拟色彩变化中的色值大小变化，透明度的变化。如果是处理色彩变化，最好是先把色值分为r,g,b后独立地对rgb三个值进行修正。如下实现：    

```js

    //设置初始化值  
    var red = 255,green = 0,blue = 0,redTarget = 0,greenTarget = 0,blueTarget = 255;  
    //对R,G,B三角分别做处理  
    red += (redTarget - red) * easing;  
    green += (greenTarget - green) * easing;  
    blue += (blueTarget - blue) * easing;  
    //将R,G,B形式的色彩转换为16进制表示法  
    var color = red << 16 | green << 8 | blue;  

```    
透明度的处理也可以按此模式：

    alpha += (targetAlpha - alpha) * easing;  
    ball.color = "rgba(255, 0, 0," + alpha + ")";  

###复杂缓冲


对于缓冲的处理，我们介绍了最简单的处理方式，复杂的方式通常是以一条或多条曲线来模拟整个速度的变化，参见【http://flashblog.robertpenner.com/（flash版本）】及javascript版本【https://github.com/lamberta/html5-animation/tree/master/xtras/easing-equations】


###HTML5 WebGame开源工具之impactjs
